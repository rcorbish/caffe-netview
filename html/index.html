<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" href="css/index.css">
<script src="https://d3js.org/d3.v4.min.js"></script>
<meta charset="UTF-8">
<title>Caffe viewer</title>
</head>
<body>

	<div class='menu'>
		<div id='proto-drop-site' class='drop-site'>drop a prototxt file
			or URL here</div>
		<div class='controls'>
			<div class='slider-label'>link tension</div>
			<input type='range' id='tension' min=0 max=1.2 step=.1></input> <br>
			<div class='slider-label'>node repulsion</div>
			<input type='range' id='charge' min=0 max=100 step=5></input> <br>
			<div class='slider-label'>node radius</div>
			<input type='range' id='radius' min=0 max=200 step=5></input>
		</div>
		<div class='stages'></div>
	</div>

	<div class="net-view">
		<svg id="cloud" width="100%" height="100%" >
		<g class='network'></g>
		</svg>
	</div>

	<script>
var protoText = null ;
var protoUrl = null ;

function init() {

	const xhr = new XMLHttpRequest();
	if( !xhr.upload ) {
		alert( "This browser is not supported." ) ;
		return ;
	}

	const sliders = document.querySelectorAll( "input[type='range']" ) ;
	for( var i=0 ; i<sliders.length ; i++ ) {
		sliders[i].addEventListener("change", Redraw, false ) ;
	}
		
	const dropSite = document.querySelector( ".drop-site" ) ;
	
	// file drop
	dropSite.addEventListener("dragover", FileDragHover, false);
	dropSite.addEventListener("dragleave", FileDragHover, false);
	dropSite.addEventListener("drop", FileDropped, false);

	function FileDragHover(e) {
		e.stopPropagation() ;
		e.preventDefault() ;
		var currentClassName = e.target.className || "" ;
		currentClassName = currentClassName.replace( /[\s]*drop-hover[\s]*/, " " ) ;
		if( e.type === "dragover" ) currentClassName += " drop-hover" ;
		e.target.className = currentClassName ;
	}

	
	function FileDropped(e) {
		FileDragHover(e);
	
		var files = e.dataTransfer.files;
		if( files.length > 0 ) {
			const fileReader = new FileReader();
			fileReader.addEventListener("loadend", function(evt){
					protoText = evt.target.result ;
					protoUrl = null ;
					Redraw(); 
				}
				, false);
			fileReader.readAsBinaryString( files[0] );			
		} else {		// not a file - possibly a URL
			protoUrl = e.dataTransfer.getData( 'text/plain' ) ;
			protoText = null ;
			Redraw(); 
		}
	}	
}



function Redraw() {
	const xhr = new XMLHttpRequest();

	var stageParam = null ;
	const stages = document.querySelector( ".stages" ) ;
	const stageCheckboxes = stages.querySelectorAll( "input" ) ;
	const checkedStages = [] ;
	for( let i=0 ; i<stageCheckboxes.length ; i++ ) {
		let stageCheckbox = stageCheckboxes[i] ;
		if( stageCheckbox.checked ) {
			checkedStages.push( stageCheckbox.name ) ;
		}
	}
	
	const charge = document.getElementById("charge").value ;
	const tension = document.getElementById("tension").value ;
	const radius = document.getElementById("radius").value ;
	xhr.open("POST", "upload?charge="+charge+"&tension="+tension+"&radius="+radius+"&stage="+checkedStages.join('&stage=') );
	xhr.setRequestHeader( "accept", "text/html" ) ;
	xhr.overrideMimeType('application/javascript; charset=utf-8');
	xhr.onreadystatechange = function() {
		if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
			let data = JSON.parse( xhr.responseText ) ;
			defineStages( data ) ;
			drawView( data ) ;
	    }
	} ;
	
	if( protoText ) {
		xhr.setRequestHeader("Content-Type", "application/x-prototext");
		xhr.send( protoText ) ;
	} 
	if( protoUrl ) {
		xhr.setRequestHeader("Content-Type", "text/uri-list");
		xhr.send( protoUrl ) ;
	}	
}

function defineStages( netobj ) {
	const stages = document.querySelector( ".stages" ) ;
	const stageCheckboxes = stages.querySelector( "input[type='checkbox']" ) ;
	
	if( stageCheckboxes ) {
		for( let i=0 ; i<stageCheckboxes.length ; i++ ) {
			let stageCheckbox = stageCheckboxes[i] ;
			let nm = stageCheckbox.name ;
			if( netobj.stages.indexOf( nm ) < 0 ) {
				stages.removeChild( stageCheckbox );
			}
		}
	}
		
	for( let i=0 ; i<netobj.stages.length ; i++ ) {
		let nm = netobj.stages[i] ;
		let stageCheckbox = stages.querySelector( "input[name='" + nm + "']" ) ;
		if( !stageCheckbox ) {
			stageCheckbox = document.createElement( "input" ) ;
			stageCheckbox.type = 'checkbox';
			stageCheckbox.name = nm ;
			let t = document.createTextNode( nm ) ; 
			stages.appendChild( t ) ;
			stages.appendChild( stageCheckbox ) ; 
			stageCheckbox.addEventListener('change', Redraw ,false);
		}
	}
}

function drawView( netobj ) {
function dragstarted(d) {
  if (!d3.event.active) simulation.alphaTarget(0.3).restart();
  d.fx = d.x;
  d.fy = d.y;
}

function dragged(d) {
  d.fx = d3.event.x;
  d.fy = d3.event.y;
}

function dragended(d) {
  if (!d3.event.active) simulation.alphaTarget(0);
  d.fx = null;
  d.fy = null;
}

	const netView = document.getElementById( "cloud" ) ;

	while (netView.hasChildNodes()) {
    	netView.removeChild(netView.lastChild);
	}


	const svg = d3.select("svg") ;
  	const svgg = svg.append("g").attr("class", "network") ;

	const color = d3.scaleOrdinal(d3.schemeCategory20);

	const charge = document.getElementById("charge").value ;
	const tension = document.getElementById("tension").value ;
	const radius = document.getElementById("radius").value ;


  	const links = svgg
	    .selectAll("line")
    	.data(netobj.links)
    	.enter().append("line") 
    ;

  const nodes = svgg
    	.selectAll("circle")
    	.data(netobj.nodes)
    	.enter().append("circle")
      		.attr("r", function(d) { return d.type==='blob' ? 25 : (radius||50)/2 } ) 
      		.attr("fill", function(d) { return color(d.type); })
      		.call(d3.drag()
          		.on("start", dragstarted)
          		.on("drag", dragged)
          		.on("end", dragended)) 
  ;

  const texts = svgg
    	.selectAll("text")
    	.data(netobj.nodes)
    	.enter().append("text")
    	.attr( 'text-anchor', 'middle' ) 
    	.style( 'font-size', ((radius||50)/5.5) + 'px' ) 
    	.text( function(d) { return d.type==='blob' ? d.name.substring(5) : d.name } )
  ;

      
  function tick() {
    nodes
        .attr("cx", function(d) { return d.x; })
        .attr("cy", function(d) { return d.y; })
    ;
    texts
        .attr("x", function(d) { return d.x; })
        .attr("y", function(d) { return d.y; })
    ;
    
    links
        .attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; })
    ;
  }


	const simulation = d3.forceSimulation()
			.nodes( netobj.nodes ) 	
			.force( "link", d3.forceLink()
					.id( function(n) { return n.name ; } )
					.strength( function(l) { return tension||1 ; }) 
					.distance( function(l) { return 10 ; } )
					.links( netobj.links ) 
				)
			.force( "charge", d3.forceManyBody()
					.strength( -(charge||50) ) 
				)
			.force( "center", d3.forceCenter(600, 300) ) 			
			.force( "collide", d3.forceCollide( radius||20 ) ) 
			.force( "y", d3.forceY( function(d) { return 0 ; } ).strength( 0.3 ) ) 
			.force( "x", d3.forceX( function(d) { return d.xPreferred || 0 ; } ).strength( function(d) { return d.xPreferred ? 0.1 : 0.0 ; } ) )			
  		    .on("tick", tick ) 
  		    .on("end", tick ) 
  		    ;
}

window.onload = init() ;
</script>
</body>
</html>