<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" href="css/index.css" >
<meta charset="UTF-8">
<title>Caffe viewer</title>
<script src="js/three.js"></script>
<script src="js/controls/OrbitControls.js"></script>
</head>
<body>

<div id='proto-drop-site' class='drop-site'>drop a prototxt file or URL here</div>
<div id='net-view' class='net-view'></div>

<script>
function init() {

	const xhr = new XMLHttpRequest();
	if( !xhr.upload ) {
		alert( "This browser is not supported." ) ;
		return ;
	}
	
	const dropSite = document.querySelector( ".drop-site" ) ;
	
	// file drop
	dropSite.addEventListener("dragover", FileDragHover, false);
	dropSite.addEventListener("dragleave", FileDragHover, false);
	dropSite.addEventListener("drop", FileDropped, false);



	function FileDragHover(e) {
		e.stopPropagation() ;
		e.preventDefault() ;
		var currentClassName = e.target.className ;
		currentClassName = currentClassName.replace( /[\s]*drop-hover[\s]*/, " " ) ;
		if( e.type === "dragover" ) currentClassName += " drop-hover" ;
		e.target.className = currentClassName ;
	}


	function FileDropped(e) {
		FileDragHover(e);
	
		var files = e.dataTransfer.files;
		if( files.length > 0 ) {
			const fileReader = new FileReader();
			xhr.open("POST", "/upload");
			xhr.setRequestHeader( "accept", "text/html" ) ;
			xhr.overrideMimeType('application/javascript; charset=utf-8');
			fileReader.addEventListener("loadend", function(evt){
				xhr.send(evt.target.result);}
				, false);
			fileReader.readAsBinaryString( files[0] );
			
			xhr.onreadystatechange = function() {
    			if(xhr.readyState == XMLHttpRequest.DONE && xhr.status == 200) {
    				DrawView( JSON.parse( xhr.responseText ) ) ;
			    }
			} ;
		}
	}	
}

function DrawView( dat ) {
	const netView = document.getElementById( "net-view" ) ;
		
	var camera, scene, renderer;
	var group = new THREE.Group() ;
	var things = [] ;
	
	camera = new THREE.PerspectiveCamera( 45, netView.clientWidth / netView.clientHeight, 1, 1000 );
	camera.position.set( 0, 10, 180 );
	scene = new THREE.Scene();
	scene.add( new THREE.AmbientLight( 0xffffff, 0.35 ) ) ;
	
	var light = new THREE.PointLight( 0xa0a0a0 ) ;
	light.position.z = 100 ;
	scene.add( light );
		
				
	var geometry = new THREE.TorusKnotBufferGeometry( 30, 5, 100, 50 );
	var material = new THREE.MeshStandardMaterial( { color: 0x0f30f8, metalness: 0.3, roughness: 0.2, wireframe: false } );

	var thing  = new THREE.Mesh( geometry, material ) ;
	thing.position.set( 0, 0, 0 ) ;
	group.add( thing ) ;
	things.push( thing ) ;
				
	scene.add( group );
				
	renderer = new THREE.WebGLRenderer( { antialias: true } );
	renderer.setPixelRatio( netView.devicePixelRatio );
	renderer.setSize( netView.clientWidth, netView.clientHeight );
	renderer.shadowMap.enabled = true;
				
	netView.appendChild( renderer.domElement );
				
	controls = new THREE.OrbitControls( camera, renderer.domElement );
	controls.target.set( 0, 10, 10 );
	controls.update();
	window.addEventListener( 'resize', onWindowResize, false );

	function onWindowResize() {
		camera.aspect = netView.clientWidth / netView.clientHeight;
		camera.updateProjectionMatrix();
		renderer.setSize( netView.clientWidth, netView.clientHeight );
	}
	
	function animate() {
		requestAnimationFrame( animate );
		render();
	}

	function render() {
		var time = performance.now() * 0.01;
	    for( var i=0 ; i<things.length ; i++ ) {
	      things[i].rotation.x = 0.05 * time ;
	    }
		var time = performance.now() * 0.01;
		group.rotation.y = time * 0.4;
		renderer.render( scene, camera );
	}
	
	animate();
	
}



window.onload = init() ;
</script>
</body>
</html>