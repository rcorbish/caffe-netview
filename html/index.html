<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" href="css/index.css" >
<meta charset="UTF-8">
<title>Caffe viewer</title>
<script src="js/three.js"></script>
<script src="js/controls/OrbitControls.js"></script>
</head>
<body>

<div class='menu'>
	<div id='proto-drop-site' class='drop-site'>drop a prototxt file or URL here</div>
	<div class='controls'>	
		<div class='slider-label'>link tension</div><input type='range' id='tension' min=0 max=1.2 step=.1 ></input>
		<br>
		<div class='slider-label'>node repulsion</div><input type='range' id='charge' min=0 max=100 step=5 ></input>
		<br>
		<div class='slider-label'>node radius</div><input type='range' id='radius' min=0 max=200 step=5 ></input>
	</div>
	<div class='stages'>
	</div>
</div>
<div id='net-view' class='net-view'></div>

<script>
var protoText = null ;
var protoUrl = null ;

function init() {


	const xhr = new XMLHttpRequest();
	if( !xhr.upload ) {
		alert( "This browser is not supported." ) ;
		return ;
	}

	const sliders = document.querySelectorAll( "input[type='range']" ) ;
	for( var i=0 ; i<sliders.length ; i++ ) {
		sliders[i].addEventListener("change", Redraw, false ) ;
	}
		
	const dropSite = document.querySelector( ".drop-site" ) ;
	
	// file drop
	dropSite.addEventListener("dragover", FileDragHover, false);
	dropSite.addEventListener("dragleave", FileDragHover, false);
	dropSite.addEventListener("drop", FileDropped, false);

	function FileDragHover(e) {
		e.stopPropagation() ;
		e.preventDefault() ;
		var currentClassName = e.target.className ;
		currentClassName = currentClassName.replace( /[\s]*drop-hover[\s]*/, " " ) ;
		if( e.type === "dragover" ) currentClassName += " drop-hover" ;
		e.target.className = currentClassName ;
	}

	
	function FileDropped(e) {
		FileDragHover(e);
	
		var files = e.dataTransfer.files;
		if( files.length > 0 ) {
			const fileReader = new FileReader();
			fileReader.addEventListener("loadend", function(evt){
					protoText = evt.target.result ;
					protoUrl = null ;
					Redraw(); 
				}
				, false);
			fileReader.readAsBinaryString( files[0] );			
		} else {		// not a file - possibly a URL
			protoUrl = e.dataTransfer.getData( 'text/plain' ) ;
			protoText = null ;
			Redraw(); 
		}
	}	
}

function Redraw() {
	const xhr = new XMLHttpRequest();

	var stageParam = null ;
	const stages = document.querySelector( ".stages" ) ;
	const stageCheckboxes = stages.querySelectorAll( "input" ) ;
	const checkedStages = [] ;
	for( let i=0 ; i<stageCheckboxes.length ; i++ ) {
		let stageCheckbox = stageCheckboxes[i] ;
		if( stageCheckbox.checked ) {
			checkedStages.push( stageCheckbox.name ) ;
		}
	}
	
	const charge = document.getElementById("charge").value ;
	const tension = document.getElementById("tension").value ;
	const radius = document.getElementById("radius").value ;
	xhr.open("POST", "upload?charge="+charge+"&tension="+tension+"&radius="+radius+"&stage="+checkedStages.join('&stage=') );
	xhr.setRequestHeader( "accept", "text/html" ) ;
	xhr.overrideMimeType('application/javascript; charset=utf-8');
	xhr.onreadystatechange = function() {
		if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
			let data = JSON.parse( xhr.responseText ) ;
			defineStages( data ) ;
			drawView( data ) ;
	    }
	} ;
	
	if( protoText ) {
		xhr.setRequestHeader("Content-Type", "application/x-prototext");
		xhr.send( protoText ) ;
	} 
	if( protoUrl ) {
		xhr.setRequestHeader("Content-Type", "text/uri-list");
		xhr.send( protoUrl ) ;
	}	
}

function defineStages( netobj ) {
	const stages = document.querySelector( ".stages" ) ;
	const stageCheckboxes = stages.querySelector( "input[type='checkbox']" ) ;
	
	if( stageCheckboxes ) {
		for( let i=0 ; i<stageCheckboxes.length ; i++ ) {
			let stageCheckbox = stageCheckboxes[i] ;
			let nm = stageCheckbox.name ;
			if( netobj.stages.indexOf( nm ) < 0 ) {
				stages.removeChild( stageCheckbox );
			}
		}
	}
		
	for( let i=0 ; i<netobj.stages.length ; i++ ) {
		let nm = netobj.stages[i] ;
		let stageCheckbox = stages.querySelector( "input[name='" + nm + "']" ) ;
		if( !stageCheckbox ) {
			stageCheckbox = document.createElement( "input" ) ;
			stageCheckbox.type = 'checkbox';
			stageCheckbox.name = nm ;
			let t = document.createTextNode( nm ) ; 
			stages.appendChild( t ) ;
			stages.appendChild( stageCheckbox ) ; 
			stageCheckbox.addEventListener('change', Redraw ,false);
		}
	}
}

function drawView( netobj ) {
	const netView = document.getElementById( "net-view" ) ;

	while (netView.hasChildNodes()) {
    	netView.removeChild(netView.lastChild);
	}
		
		
	var camera, scene, renderer;
	var group = new THREE.Group() ;
	var things = [] ;
	
	camera = new THREE.PerspectiveCamera( 45, netView.clientWidth / netView.clientHeight, 1, 2400 );
	camera.position.set( 0, 0, 600 );
	scene = new THREE.Scene();
	scene.add( new THREE.AmbientLight( 0xffffff, 0.35 ) ) ;
	
	var light = new THREE.PointLight( 0xa0a0a0 ) ;
	light.position.z = 100 ;
	scene.add( light );

	var blueMaterial 	= new THREE.MeshStandardMaterial( { color: 0x0f30f8, metalness: 0.3, roughness: 0.2 } );
	var greenMaterial 	= new THREE.MeshStandardMaterial( { color: 0x0fc838, metalness: 0.0, roughness: 0.7 } );
	var orangeMaterial 	= new THREE.MeshStandardMaterial( { color: 0xd0c826, metalness: 0.1, roughness: 1.0 } );
	var pinkMaterial 	= new THREE.MeshStandardMaterial( { color: 0xf070c0, metalness: 0.5, roughness: 0.1 } );
	var silverMaterial 	= new THREE.MeshStandardMaterial( { color: 0x8090a0, metalness: 0.6, roughness: 0.1 } );
	
	var whiteMaterial = new THREE.LineBasicMaterial( { color: 0xffffff, metalness: 0.3, roughness: 0.2 } );
		
	var arrowIn = new THREE.Shape();
	arrowIn.moveTo( 15, 0 );
	arrowIn.lineTo( 0, 15 );
	arrowIn.lineTo( -15, 15 );
	arrowIn.lineTo( -15, -15 );
	arrowIn.lineTo( 0, -15 );
	arrowIn.lineTo( 15, 0 );

	var arrowOut = new THREE.Shape();
	arrowOut.moveTo( 0, 0  );
	arrowOut.lineTo( -15, 15 );
	arrowOut.lineTo( 15, 15  );
	arrowOut.lineTo( 15, -15 );
	arrowOut.lineTo( -15, -15 );
	arrowOut.lineTo( 0, 0  );

	var poolGeometry = new THREE.BufferGeometry();
	const poolVertices = new Float32Array( [
		  // Front face
		  -15.0, -15.0,  15.0,
		   15.0, -5.0,  5.0,
		   15.0,  5.0,  5.0,
		  -15.0,  15.0,  15.0,
		  
		  // Back face
		  -15.0, -15.0, -15.0,
		  -15.0,  15.0, -15.0,
		   15.0,  5.0, -5.0,
		   15.0, -5.0, -5.0,
		  
		  // Top face
		  -15.0,  15.0, -15.0,
		  -15.0,  15.0,  15.0,
		   15.0,  5.0,  5.0,
		   15.0,  5.0, -5.0,
		  
		  // Bottom face
		  -15.0,  -15.0, -15.0,
		   15.0,  -5.0, -5.0,
		   15.0,  -5.0,  5.0,
		  -15.0, -15.0,  15.0,
		  
		  // Right face
		   15.0, -5.0, -5.0,
		   15.0,  5.0, -5.0,
		   15.0,  5.0,  5.0,
		   15.0, -5.0,  5.0,
		  
		  // Left face
		  -15.0, -15.0, -15.0,
		  -15.0, -15.0,  15.0,
		  -15.0,  15.0,  15.0,
		  -15.0,  15.0, -15.0
  	] );
	
	const poolVertexIndices = new Uint16Array([
	  0,  1,  2,      0,  2,  3,    // front
	  4,  5,  6,      4,  6,  7,    // back
	  8,  9,  10,     8,  10, 11,   // top
	  12, 13, 14,     12, 14, 15,   // bottom
	  16, 17, 18,     16, 18, 19,   // right
	  20, 21, 22,     20, 22, 23    // left
	] );
	poolGeometry.setIndex( new THREE.BufferAttribute( poolVertexIndices, 1 ) );
	poolGeometry.addAttribute( 'position', new THREE.BufferAttribute( poolVertices, 3 ) );
 	poolGeometry.computeVertexNormals() ;
 	poolGeometry.computeBoundingSphere() ;
 	
 	const extrudeSettings = {
			steps: 1,
			amount: 10,
			bevelEnabled: false
	};
	var defaultGeometry = new THREE.BoxBufferGeometry( 30, 30, 30 );
	var blobGeometry = new THREE.OctahedronBufferGeometry( 10 );	
	var dataGeometry = new THREE.CylinderBufferGeometry( 15, 15, 15, 20 );	
	var inputGeometry = new THREE.ExtrudeGeometry( arrowIn, extrudeSettings );
	var outputGeometry = new THREE.ExtrudeGeometry( arrowOut, extrudeSettings );
	var learnGeometry = new THREE.ConeBufferGeometry( 15, 30, 130 );
	
	var convGroup = new THREE.Group() ;
	for( let x=0 ; x<2 ; x++ ) {
		for( let y=-1 ; y<2 ; y++ ) {
			for( let z=-1 ; z<2 ; z++ ) {
				let box = new THREE.BoxBufferGeometry( 8, 8, 8 ) ;
				let mesh = new THREE.Mesh( box, greenMaterial ) ;
				mesh.position.set( 10 * x, 10 * y, 10 * z ) ;
				convGroup.add( mesh ) ;
			}
		}
	}
	let box = new THREE.BoxBufferGeometry( 8, 30, 30 ) ;
	let mesh = new THREE.Mesh( box, greenMaterial ) ;
	mesh.position.set( -10, 0, 0 ) ;
	convGroup.add( mesh ) ;


	var innerProductGroup = new THREE.Group() ;
	const ball = new THREE.SphereBufferGeometry( 4.75, 30, 30 ) ;
	for( let y=-1 ; y<2 ; y++ ) {
		for( let z=-1 ; z<2 ; z++ ) {
			let mesh1 = new THREE.Mesh( ball, blueMaterial ) ;
			mesh1.position.set( -10, 10 * y, 10 * z ) ;
			innerProductGroup.add( mesh1 ) ;

			let mesh2 = new THREE.Mesh( ball, blueMaterial ) ;
			mesh2.position.set( 10, 10 * y, 10 * z ) ;
			innerProductGroup.add( mesh2 ) ;

			var src =  new THREE.Vector3( -10, 10*y, 10*z ) ;
			for( let y2=-1 ; y2<2 ; y2++ ) {
				for( let z2=-1 ; z2<2 ; z2++ ) {	
					if( y2!=y && z2!=z ) {
					
						let curve = new THREE.LineCurve3( src, new THREE.Vector3( 10, 10*y2, 10*z2 ) );		
						let path = new THREE.Path( curve.getPoints() );
						let geometry = path.createPointsGeometry();
 						
						innerProductGroup.add( new THREE.Line( geometry, whiteMaterial ) ) ;
					}
				}			
			}
		}
	}

	var accuracyGeometry = new THREE.TetrahedronBufferGeometry( 10 );
	var softmaxGeometry = new THREE.TorusBufferGeometry( 5, 2, 15, 32 );
	var reluGeometry = new THREE.IcosahedronBufferGeometry( 5 );
		
	var type, geometry, z ;
	for( var i=0 ; i<netobj.nodes.length ; i++ ) {
		let node = netobj.nodes[i] ;
		z = 0 ;
		rot = 0 ;
		type = node.type.toLowerCase() ;
		geometry = defaultGeometry ;
		material = blueMaterial ;
		
		if( type === 'blob' ) 		{ 
			if( node.layer ) {
				geometry = defaultGeometry ; material = silverMaterial ;
			} else {
				geometry = blobGeometry ; material = greenMaterial ;
			} 
		}
		if( type === 'pooling' ) 	{ geometry = poolGeometry ; }
		if( type === 'data' ) 		{ geometry = dataGeometry ; material=pinkMaterial ; }
		if( type === 'input' ) 		{ geometry = inputGeometry ; z = -5 ; material=pinkMaterial ; }
		if( type.startsWith( 'softmax' ) ) 	{ geometry = outputGeometry ; z = -5 ; material=orangeMaterial ; }
		if( type === 'accuracy' ) 	{ geometry = learnGeometry ; rot = Math.PI/2 ; material=orangeMaterial ; }
		if( type === 'loss' ) 		{ geometry = learnGeometry ; rot = Math.PI/2 ; material=orangeMaterial ; }
	
		var thing ;		
		if( type === 'convolution' ) { 
			thing = convGroup.clone() ; 
		} else if( type === 'innerproduct' ) { 
			thing = innerProductGroup.clone() ; 
		} else {
			thing  = new THREE.Mesh( geometry, material ) ;
			if( rot ) {
				thing.rotation.z = rot ;
			}
		}
		thing.position.set( node.x, node.y, z ) ;
		thing.name = node.name ;
		group.add( thing ) ;
		things.push( thing ) ;
	}

	for( var i=0 ; i<netobj.links.length ; i++ ) {
		// turn the link IDs into actual things we are drawing
		// each thing is given the name of its caffe layer
		src = things.find( function(e) { return e.name === netobj.links[i].source.name ; } ) ;
		tgt = things.find( function(e) { return e.name === netobj.links[i].target.name ; } ) ;
		
		// create a line - in 3js this is how we do it ...
		var curve = new THREE.LineCurve3( src.position, tgt.position ) ;	
		var path = new THREE.Path( curve.getPoints() );
		var geometry = path.createPointsGeometry();
	
		var thing = new THREE.Line( geometry, whiteMaterial );

		group.add( thing ) ;
		things.push( thing ) ;
	}		
			
	scene.add( group );
				
	renderer = new THREE.WebGLRenderer( { antialias: true } );
	renderer.setPixelRatio( netView.devicePixelRatio );
	renderer.setSize( netView.clientWidth, netView.clientHeight );
	renderer.shadowMap.enabled = true;
				
	netView.appendChild( renderer.domElement );
				
	controls = new THREE.OrbitControls( camera, renderer.domElement );
	controls.target.set( 0, 10, 10 );
	controls.update();
	controls.addEventListener('change', render ,false);
	
	window.addEventListener( 'resize', onWindowResize, false );

	function onWindowResize() {
		camera.aspect = netView.clientWidth / netView.clientHeight;
		camera.updateProjectionMatrix();
		renderer.setSize( netView.clientWidth, netView.clientHeight );
		render() ;
	}

	function render() {
		renderer.render( scene, camera );
	}
	
	render();
}



window.onload = init() ;
</script>
</body>
</html>